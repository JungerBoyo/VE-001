#version 450 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(std140, binding = 2) uniform MeshingDescriptor {
    uint vbo_offsets[6];
    ivec3 chunk_position;
    ivec3 chunk_size;
};

layout(std430, binding = 5) readonly buffer VoxelData {
    uint voxel_data[];
};

struct Vertex {
    vec3 position;
    vec3 texcoord;
};

layout(std430, binding = 6) buffer MeshData {
    uint written_vertex_counts[6]; // = { +x, -x, +y, -y, +z, -z }
    uint axes_steps[6];
    Vertex vbo[];
};

shared uint local_mesh_vertex_count;

const vec3 VERTICES[8] = {
    vec3(0.0, 0.0, 0.0),
    vec3(0.0, 0.0, 1.0),
    vec3(0.0, 1.0, 0.0),
    vec3(0.0, 1.0, 1.0),
    vec3(1.0, 0.0, 0.0),
    vec3(1.0, 0.0, 1.0),
    vec3(1.0, 1.0, 0.0),
    vec3(1.0, 1.0, 1.0)
};
const vec2 TEX_COORDS[6] = {
    vec2(0.0, 0.0),
    vec2(1.0, 0.0),
    vec2(1.0, 1.0),
    vec2(0.0, 0.0),
    vec2(1.0, 1.0),
    vec2(0.0, 1.0)
};
const uint INDICES[36] = {
	5, 4, 6, 5, 6, 7, // +x
	0, 1, 3, 0, 3, 2, // -x
	2, 3, 7, 2, 7, 6, // +y
	4, 5, 1, 4, 1, 0, // -y
	1, 5, 7, 1, 7, 3, // +z
	4, 0, 2, 4, 2, 6  // -z
};

void main() {
    uint face_id = gl_GlobalInvocationID.x % 6;
    uint face_id_in_indices = face_id * 6;
    uint axis_step = gl_LocalInvocationIndex + axes_steps[face_id];

    ///         START          ///
    if (gl_LocalInvocationIndex == 0) {
        local_mesh_vertex_count = written_vertex_counts[face_id];
    }
    memoryBarrierShared();
    barrier();
    ///////////////////////////////

    uint axis_id = face_id / 2;

    uvec3 logical_indices = uvec3((axis_id + 1) % 3, (axis_id + 2) % 3, axis_id);
    uvec3 real_indices = uvec3(
        (2 + axis_id * 2) % 3,
        (0 + axis_id * 2) % 3,
        (1 + axis_id * 2) % 3
    );
    // positions the args in logical way where 
    // Z - is the current axis
    // X, Y - are extents of the plane perpedicular to the axis
    ivec3 logical_extent = ivec3(
        chunk_size[logical_indices[0]],
        chunk_size[logical_indices[1]],
        chunk_size[logical_indices[2]]
    );

    // depending on the meshing axis (eg. pos/neg), 
    int edge_value = (face_id % 2) == 1 ? 0 : logical_extent[2] - 1;
    int polarity   = (face_id % 2) == 1 ?-1 : 1;

    uvec2 squashed_extent_logical_indices = axis_id == 0 ? uvec2(1, 0) : uvec2(0, 1);

    uint states[128];
    for (int i=0; i<128; ++i) {
        states[i] = 0;
    }

    const int plane_size = chunk_size.x * chunk_size.y;

    ivec3 i = ivec3(0, 0, int(axis_step));

    /// Fill the visibility query
    for (;i[1] < logical_extent[1]; ++i[1]) {
        i[0] = 0;
        for (;i[0] < logical_extent[0]; ++i[0]) {
            uint voxel_index = i[real_indices[0]] + i[real_indices[1]] * chunk_size.x + i[real_indices[2]] * plane_size;
            if ((voxel_data[voxel_index >> 1] & (0xFFFF << (voxel_index & 1))) > 0) {
                if (i[2] == edge_value) {
                    uint state_index = i[0] + i[1] * logical_extent[0];
                    states[state_index >> 5] |= (1 << (state_index & 31));
                    continue;
                }
            }
            i[2] += polarity;
            voxel_index = i[real_indices[0]] + i[real_indices[1]] * chunk_size.x + i[real_indices[2]] * plane_size;      
            if ((voxel_data[voxel_index >> 1] & (0xFFFF << (voxel_index & 1))) == 0) {
                uint state_index = i[0] + i[1] * logical_extent[0];
                states[state_index >> 5] |= (1 << (state_index & 31));
            }
            i[2] -= polarity;
        }
    }

    i[1] = 0;
    for (;i[1] < logical_extent[1]; ++i[1]) {
        i[0] = 0;
        while(i[0] < logical_extent[0]) {
            uint state_index = i[0] + i[1] * logical_extent[0];
            if ((states[state_index >> 5] & (1 << (state_index & 31))) > 0) {
                uint voxel_index = i[real_indices[0]] + i[real_indices[1]] * chunk_size.x + i[real_indices[2]] * plane_size;
                uint voxel_value = (voxel_data[voxel_index >> 1] & (0xFFFF << (voxel_index & 1))) >> (voxel_index & 1);

                ivec3 mesh_region = ivec3(1, 1, 0);
                for (;i[0] + mesh_region[0] < logical_extent[0]; ++mesh_region[0]) {
                    voxel_index = 
                        (i[real_indices[0]] + mesh_region[real_indices[0]]) + 
                        (i[real_indices[1]] + mesh_region[real_indices[1]]) * chunk_size.x + 
                        (i[real_indices[2]] + mesh_region[real_indices[2]]) * plane_size;
                    uint next_voxel_value = (voxel_data[voxel_index >> 1] & (0xFFFF << (voxel_index & 1))) >> (voxel_index & 1);
                    if (next_voxel_value != voxel_value) {
                       break; 
                    }
                }

                for (;i[1] < logical_extent[1]; ++i[1]) {
                    uvec3 tmp_mesh_region = uvec3(0);
                    bool _break = false;
                    for (;i[0] + tmp_mesh_region[0] < i[0] + mesh_region[0]; ++tmp_mesh_region[0]) {
                        voxel_index = 
                            (i[real_indices[0]] + tmp_mesh_region[real_indices[0]]) + 
                            (i[real_indices[1]] + tmp_mesh_region[real_indices[1]]) * chunk_size.x + 
                            (i[real_indices[2]] + tmp_mesh_region[real_indices[2]]) * plane_size;
                        uint next_voxel_value = (voxel_data[voxel_index >> 1] & (0xFFFF << (voxel_index & 1))) >> (voxel_index & 1);
                        if (next_voxel_value != voxel_value) {
                            _break = true;
                            break;
                        }
                    }
                    if (_break) {
                        break;
                    }
                }

                ivec3 region_extent = ivec3(0);
                region_extent[logical_indices[2]] = 1;
                region_extent[logical_indices[1]] = mesh_region[1];
                region_extent[logical_indices[0]] = mesh_region[0];

                ivec2 squashed_region_extent = ivec2(
                    mesh_region[squashed_extent_logical_indices[0]],
                    mesh_region[squashed_extent_logical_indices[1]]
                );

                ivec3 region_offset = chunk_position;
                region_offset[logical_indices[2]] += i[2];
                region_offset[logical_indices[1]] += i[1];
                region_offset[logical_indices[0]] += i[0];

                uint base_vertices_index = atomicAdd(local_mesh_vertex_count, 6);
                float voxel_value_encoded = float(6 * voxel_value);

                vbo[vbo_offsets[face_id] + base_vertices_index + 0] = Vertex(
                    region_extent * VERTICES[INDICES[face_id_in_indices + 0]] + region_offset, 
                    vec3(squashed_region_extent * TEX_COORDS[0], voxel_value_encoded + 0.0)
                );
                vbo[vbo_offsets[face_id] + base_vertices_index + 1] = Vertex(
                    region_extent * VERTICES[INDICES[face_id_in_indices + 1]] + region_offset, 
                    vec3(squashed_region_extent * TEX_COORDS[1], voxel_value_encoded + 1.0)
                );
                vbo[vbo_offsets[face_id] + base_vertices_index + 2] = Vertex(
                    region_extent * VERTICES[INDICES[face_id_in_indices + 2]] + region_offset, 
                    vec3(squashed_region_extent * TEX_COORDS[2], voxel_value_encoded + 2.0)
                );
                vbo[vbo_offsets[face_id] + base_vertices_index + 3] = Vertex(
                    region_extent * VERTICES[INDICES[face_id_in_indices + 3]] + region_offset, 
                    vec3(squashed_region_extent * TEX_COORDS[3], voxel_value_encoded + 3.0)
                );
                vbo[vbo_offsets[face_id] + base_vertices_index + 4] = Vertex(
                    region_extent * VERTICES[INDICES[face_id_in_indices + 4]] + region_offset, 
                    vec3(squashed_region_extent * TEX_COORDS[4], voxel_value_encoded + 4.0)
                );
                vbo[vbo_offsets[face_id] + base_vertices_index + 5] = Vertex(
                    region_extent * VERTICES[INDICES[face_id_in_indices + 5]] + region_offset, 
                    vec3(squashed_region_extent * TEX_COORDS[5], voxel_value_encoded + 5.0)
                );
     

                for (int y = i[1]; y < i[1] + mesh_region[1]; ++y) {
                    for (int x = i[0]; x < i[0] + mesh_region[0]; ++x) {
                        uint state_index = x + y * logical_extent[0];
                        states[state_index >> 5] &= ~(1 << (state_index & 31));
                    }
                }

                i[0] += mesh_region[0];
            } else {
                ++i[0];
            }
        }
    }


    ///         END         ///
    barrier();
    memoryBarrierShared();
    if (gl_LocalInvocationIndex == 0) {
        written_vertex_counts[face_id] = local_mesh_vertex_count;
        axes_steps[face_id] += 32;
    }
    ///////////////////////////////
}